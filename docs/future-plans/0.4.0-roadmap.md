# Opossum 0.4.0 — Release Roadmap

> **Status:** Planning
> **Target release:** 0.4.0
> **Builds on:** 0.3.0-preview.1 (multi-context, streaming reads, `Apply(SequencedEvent)`)

This document captures improvements planned for the 0.4.0 milestone.
Items here were explicitly deferred from 0.3.0 because they do not affect the 0.3.0 API
surface, carry non-trivial implementation risk, or require additional design decisions.

---

## Overview

| # | Feature | Breaking? | Effort |
|---|---------|-----------|--------|
| 1 | [Cache compiled delegate in `ReflectionMessageHandler`](#1-cache-compiled-delegate-in-reflectionmessagehandler) | No | Medium |

---

## 1. Cache Compiled Delegate in `ReflectionMessageHandler`

### Current state

`ReflectionMessageHandler.HandleAsync` dispatches every message via `MethodInfo.Invoke`:

```csharp
result = _method.Invoke(handlerInstance, args);
```

`_method` and `_parameters` are stored at construction time, so the handler avoids
repeated `GetMethod` / `GetParameters` lookups. However, `MethodInfo.Invoke` itself
still pays a per-call price:

- **Boxing** — value-type arguments are boxed into `object?[]` on every dispatch.
- **Security and visibility checks** — the CLR re-validates accessibility on each
  invocation unless the method was explicitly JIT-compiled into an open delegate.
- **`TargetInvocationException` wrapping** — exceptions thrown by the handler are
  wrapped and must be explicitly unwrapped, adding a catch block to the hot path.
- **No inlining** — the JIT cannot inline through a reflection call site.

For low-throughput mediator usage (e.g. one command per HTTP request) this overhead is
negligible. For high-throughput scenarios — batch processing, event replay driving
mediator dispatch, or benchmarks comparing Opossum to other mediator libraries — the
`Invoke` overhead becomes a measurable bottleneck.

### Why deferred from 0.3.0

- Does not affect any 0.3.0 public API surface.
- Non-trivial implementation: compiled delegates and expression trees require careful
  handling of open-instance methods, static methods, `async Task<T>` return types, and
  the existing `CancellationToken` resolution logic.
- Risk of subtle regression in edge cases (generic handlers, interface dispatch, static
  handlers) that would be harder to diagnose than a pure API change.
- 0.3.0 bandwidth is fully occupied by three breaking API changes.

### Why this matters

Every `await mediator.SendAsync(command)` call currently pays `MethodInfo.Invoke` overhead.
At 10,000 commands/second — plausible for a batch-processing use case — the per-call
overhead accumulates. A compiled open delegate eliminates boxing, removes the `Invoke`
trampoline, and lets the JIT inline the async state machine setup.

The improvement is especially visible in the replay scenario introduced by 0.3.0's
streaming reads: a projection that dispatches events through the mediator (for side-effect
processing) can hit tens of thousands of `HandleAsync` calls during a rebuild.

### Proposed implementation

Replace `MethodInfo.Invoke` with a compiled open delegate created once at construction
time and cached in a `readonly` field:

```csharp
// Compiled once per handler registration — paid at startup, not per-dispatch
private readonly Func<object?, object?[], object?> _compiled;

public ReflectionMessageHandler(Type handlerType, MethodInfo method)
{
    // ... existing null checks and field assignments ...

    _compiled = BuildCompiledDelegate(handlerType, method);
}

private static Func<object?, object?[], object?> BuildCompiledDelegate(
    Type handlerType, MethodInfo method)
{
    // instance parameter (null for static methods)
    var instanceParam = Expression.Parameter(typeof(object), "instance");
    // args array parameter
    var argsParam = Expression.Parameter(typeof(object[]), "args");

    var parameters = method.GetParameters();
    var argExpressions = new Expression[parameters.Length];
    for (int i = 0; i < parameters.Length; i++)
    {
        argExpressions[i] = Expression.Convert(
            Expression.ArrayIndex(argsParam, Expression.Constant(i)),
            parameters[i].ParameterType);
    }

    Expression? instanceExpr = method.IsStatic
        ? null
        : Expression.Convert(instanceParam, handlerType);

    var callExpr = Expression.Call(instanceExpr, method, argExpressions);

    Expression body = method.ReturnType == typeof(void)
        ? Expression.Block(callExpr, Expression.Constant(null, typeof(object)))
        : Expression.Convert(callExpr, typeof(object));

    return Expression.Lambda<Func<object?, object?[], object?>>(
        body, instanceParam, argsParam).Compile();
}
```

`HandleAsync` then replaces `_method.Invoke` with `_compiled(handlerInstance, args)`,
and the `TargetInvocationException` catch block is removed (compiled delegates rethrow
the original exception directly).

### Implementation considerations

- **Expression tree approach** is safer than `Delegate.CreateDelegate` for the general
  case because it handles static methods, instance methods, and different return types
  (`void`, `Task`, `Task<T>`) uniformly.
- **`async Task<T>` result extraction** — the existing `resultProperty?.GetValue(task)`
  reflection call for reading `Task<T>.Result` should also be replaced with a compiled
  accessor, or replaced by casting to `dynamic` / using `Task.ContinueWith` with typed
  continuations.
- **Startup cost** — `Expression.Compile()` is non-trivial but paid once per handler
  registration (at `AddMediator()` startup), not per dispatch. Acceptable trade-off.
- **Test coverage** — the existing `ReflectionMessageHandler` tests must be extended to
  cover static handlers, void-return handlers, and `Task<T>`-return handlers to guard
  against regressions in the compiled-delegate path.

### Breaking impact

None. This is a pure internal implementation change. The public `IMessageHandler` and
`Mediator` APIs are unchanged. Existing handler implementations require no modification.

### Performance expectation

| Scenario | Before | After (estimate) |
|----------|--------|-----------------|
| Single command dispatch | ~2–5 µs (`Invoke` overhead) | ~0.1–0.3 µs (delegate call) |
| 10,000 commands/s sustained | measurable CPU in profiler | negligible |
| Projection replay (streaming, 100k events) | `Invoke` in hot loop | inlined delegate |

Actual numbers should be verified with a `ReflectionMessageHandler` micro-benchmark
added to `Opossum.BenchmarkTests` before shipping this change.
