# Opossum 0.3.0-preview.1 — Release Roadmap

> **Status:** In Progress
> **Target release:** 0.3.0-preview.1
> **Builds on:** 0.2.0-preview.1 (full DCB compliance, Decision Model projection layer)

This document captures the six planned improvements for the 0.3.0-preview.1 milestone.
The first three are the originally-scoped **API-level breaking changes**; items 4–6 were
previously listed as deferred backlog candidates and have been **promoted into this milestone**
after prioritisation. All breaking changes are grouped into a single pre-release to avoid
asking consumers to absorb multiple consecutive breaking releases.

A seventh item — `IEventStoreMaintenance.AddTagsAsync` — was added mid-milestone as a
new feature request. It shipped alongside item 5 (immutable types).

---

## Overview

All six items ship together in 0.3.0. Items 4–6 were originally deferred; they have been
promoted after prioritisation because bundling them now avoids additional breaking releases.

| Tier | # | Feature | Breaking? | Effort | Status |
|------|---|---------|-----------|--------|--------|
| 1 | 3 | [`Apply` receives `SequencedEvent` instead of `IEvent`](#3-apply-receives-sequencedevent-instead-of-ievent) | Yes — `IProjectionDefinition<TState>` signature changes | Small | ✅ Done |
| 1 | 4 | `CancellationToken` on `AppendAsync(NewEvent[], AppendCondition?)` | Yes — new parameter | Small | ⬜ Pending |
| 2 | 2 | [Streaming reads via `IAsyncEnumerable<SequencedEvent>`](#2-streaming-reads-via-iasyncenumerablesequencedevent) | Yes — `IEventStore.ReadAsync` return type changes | Medium | ⬜ Pending |
| 2 | 5 | `Tag` and `QueryItem` as immutable `record` types | Yes — construction syntax changes | Small | ✅ Done |
| 2 | 7 | [`IEventStoreMaintenance.AddTagsAsync` — additive tag migration](#7-ieventstoretenanceaddtagsasync) | No — additive API | Small | ✅ Done |
| 3 | 1 | [Multi-context support](#1-multi-context-support) | Yes — new parameter on `ReadAsync` / `AppendAsync` | Large | ⬜ Pending |
| 3 | 6 | Extract `TagIndex`/`EventTypeIndex` duplication to a shared utility | No — internal refactor | Small | ⬜ Pending |

---

## 1. Multi-context Support

### Current state

`FileSystemEventStore.AppendAsync` and `ReadAsync` both hard-code `_options.Contexts[0]`
for every operation:

```csharp
// FileSystemEventStore — same pattern in AppendAsync and ReadAsync
// MVP LIMITATION: Only Contexts[0] is used. Multi-context support planned for future release.
var contextPath = GetContextPath(_options.Contexts[0]);
```

`ProjectionManager` makes the same assumption:

```csharp
// ProjectionManager constructor
var contextPath = Path.Combine(options.RootPath, options.Contexts[0]);
_checkpointPath = Path.Combine(contextPath, "Projections", "_checkpoints");
```

`OpossumOptions.Contexts` is already a `List<string>` and `AddContext()` works, but any
context beyond the first is silently ignored — a potential source of hard-to-diagnose bugs
for consumers who call `AddContext` more than once expecting isolation.

### Why this matters

**Bounded context isolation** is one of the core use cases that motivates a separate
event store per context. Without it, a single Opossum instance can only model one
bounded context at a time. In real-world deployments this forces consumers to either:

1. **Run multiple processes** — one per bounded context — with all the associated
   operational overhead (separate config, separate deployments, separate monitoring).
2. **Conflate all contexts into one** — mixing `CourseManagement` and `Billing` events
   into the same ledger, losing isolation and making queries noisier.

Example: an on-premises ERP covering `Sales`, `Inventory`, and `Billing` cannot use a
single Opossum instance today. The workaround is three separate root paths and three
separate service registrations, which is both wasteful and error-prone.

Multi-context support is also required before any tag-routing optimisation: the store
needs to know *which* context a read or append targets before it can apply index lookups.

### Proposed API

The cleanest approach introduces context as an optional parameter rather than a mandatory
one, preserving backward compatibility for the single-context majority:

```csharp
public interface IEventStore
{
    // context defaults to the first (and only) registered context — backward-compatible
    Task AppendAsync(NewEvent[] events, AppendCondition? condition, string? context = null);
    Task<SequencedEvent[]> ReadAsync(Query query, ReadOption[]? readOptions,
        long? fromPosition = null, string? context = null);
}
```

Extension methods keep the existing single-context call sites intact:

```csharp
// All existing callers continue to compile unchanged
await eventStore.AppendAsync(newEvent);
await eventStore.ReadAsync(Query.All());

// New multi-context callers opt in explicitly
await eventStore.AppendAsync(newEvent, condition, context: "Billing");
await eventStore.ReadAsync(Query.All(), context: "Inventory");
```

Internally, `FileSystemEventStore` resolves the context path as:

```csharp
private string ResolveContextPath(string? context)
{
    if (context == null)
        return GetContextPath(_options.Contexts[0]);

    if (!_options.Contexts.Contains(context))
        throw new ContextNotFoundException($"Context '{context}' is not configured.", context);

    return GetContextPath(context);
}
```

`ProjectionManager` needs a corresponding `context` parameter on `RegisterProjection`,
`RebuildAsync`, and `UpdateAsync` so projections can be scoped to a specific context.

### Implementation considerations

- The `StorageInitializer` already creates directories per context name — the storage
  layout is already multi-context-capable.
- The semaphore in `FileSystemEventStore` is currently shared across all appends. With
  multiple contexts, each context should have its own `SemaphoreSlim` to avoid unnecessary
  serialisation of appends to unrelated contexts. A `ConcurrentDictionary<string, SemaphoreSlim>`
  keyed by context name is the natural fit.
- `ProjectionDaemon` currently polls `Query.All()` globally. With multiple contexts it
  must poll each registered context separately or accept a context parameter.
- The existing `ContextNotFoundException` is already defined and ready to use.
- The `docs/limitations/mvp-single-context.md` limitation document should be retired
  and replaced with a multi-context usage guide.

### Breaking impact

- `IEventStore.AppendAsync` and `ReadAsync` gain a new optional `context` parameter.
  All existing call sites continue to compile; no forced migration for single-context users.
- `IProjectionManager` gains `context` parameters on projection registration and rebuild.

---

## 2. Streaming Reads via `IAsyncEnumerable<SequencedEvent>`

### Current state

`IEventStore.ReadAsync` materialises the entire result set into an array before returning:

```csharp
public async Task<SequencedEvent[]> ReadAsync(Query query, ReadOption[]? readOptions,
    long? fromPosition = null)
{
    // ...
    var positions = await GetPositionsForQueryAsync(contextPath, query, fromPosition)
        .ConfigureAwait(false);

    // All positions read into memory before the first event is returned to the caller
    var events = await _eventFileManager.ReadEventsAsync(eventsPath, positions)
        .ConfigureAwait(false);

    return events;
}
```

`EventFileManager.ReadEventsAsync` reads each event file in a loop and collects results
into a `List<SequencedEvent>` before converting to an array. Each event is a separate
JSON file on disk, read sequentially — the work is inherently incremental, but the API
forces complete materialisation.

### Why this matters

**Memory pressure on large reads.** An event log with 500,000 matching events at an
average of 1 KB per event payload occupies ~500 MB of heap before the caller processes
event number one. The current `SequencedEvent[]` model forces the caller to hold the
entire result in memory simultaneously.

**Latency to first event.** A projection rebuild that processes 1 million events cannot
start work until all 1 million events are deserialized. With `IAsyncEnumerable<SequencedEvent>`,
the projection's `Apply` function can be called as soon as the first event file is read —
overlapping I/O and CPU work, and starting to produce output much sooner.

**Composability.** `IAsyncEnumerable<T>` integrates naturally with LINQ via
`System.Linq.Async`, with `Channel<T>`-based pipelines, and with `CancellationToken`
propagation. The current array model forces every consumer to either load everything
(expensive) or build their own chunking on top of `ReadAsync` + `fromPosition`.

**The DCB specification** acknowledges this concern explicitly:
> The Event Store SHOULD return events in "some form of iterable or reactive stream"
> rather than a fully materialised collection.

For the target deployment scale (≤ 10 M events, single server) the `SequencedEvent[]`
model is workable, but the longer this stays in place the more callers build
array-centric processing logic that will be harder to migrate later.

### Proposed API

```csharp
public interface IEventStore
{
    Task AppendAsync(NewEvent[] events, AppendCondition? condition, string? context = null);

    IAsyncEnumerable<SequencedEvent> ReadAsync(
        Query query,
        ReadOption[]? readOptions,
        long? fromPosition = null,
        string? context = null,
        CancellationToken cancellationToken = default);
}
```

Callers that need an array use `ToArrayAsync()` from `System.Linq.Async`
(or a simple helper extension):

```csharp
// Callers that need a full array (e.g. DecisionModelExtensions)
var events = await eventStore.ReadAsync(query).ToArrayAsync(ct);

// Callers that stream (e.g. ProjectionManager.RebuildAsync)
await foreach (var evt in eventStore.ReadAsync(Query.All(), fromPosition: checkpoint, ct))
{
    await registration.ApplyAsync(evt, ct);
}
```

A compatibility extension keeps the `Task<SequencedEvent[]>` call pattern for consumers
that cannot yet migrate:

```csharp
// Backward-compat shim in EventStoreExtensions
public static Task<SequencedEvent[]> ReadToArrayAsync(
    this IEventStore store,
    Query query,
    ReadOption[]? readOptions = null,
    long? fromPosition = null,
    CancellationToken cancellationToken = default)
    => store.ReadAsync(query, readOptions, fromPosition, cancellationToken: cancellationToken)
            .ToArrayAsync(cancellationToken)
            .AsTask();
```

### Implementation considerations

- `EventFileManager.ReadEventsAsync` can be changed to `IAsyncEnumerable<SequencedEvent>`
  by replacing the `List<SequencedEvent>` accumulator with `yield return` — a minimal
  change to the innermost reader loop.
- `GetPositionsForQueryAsync` still returns a `long[]` (the index lookups are already
  fully in-memory). Only the event-file reading stage becomes lazy.
- The `Descending` read option is currently implemented by reversing the `positions` array
  before reading. This is still possible: reverse the positions array, then stream the
  reads in reversed order.
- All internal consumers (`DecisionModelExtensions`, `ProjectionManager.RebuildAsync`,
  `ProjectionDaemon`) must be updated to either call `.ToArrayAsync()` or adopt streaming.
  The projection rebuild path is the primary beneficiary — streaming eliminates the
  "load all 500k events then iterate" pattern.
- `System.Linq.Async` is already available to .NET 10 projects via the BCL.

### Breaking impact

- `IEventStore.ReadAsync` return type changes from `Task<SequencedEvent[]>` to
  `IAsyncEnumerable<SequencedEvent>`. Every caller must add `await foreach` or `.ToArrayAsync()`.
- The existing `EventStoreExtensions.ReadAsync(query)` and `ReadAsync(query, ReadOption)`
  overloads must be updated or replaced with new signatures.
- This is the most invasive of the three changes. It should ship alongside the others
  so consumers absorb one migration rather than three.

---

## 3. `Apply` Receives `SequencedEvent` Instead of `IEvent`

> ✅ **DONE** — shipped in this session. All projection `Apply` and `GetRelatedEventsQuery`
> signatures updated. All callers (library, tests, sample app) migrated. 801/801 tests pass.

### Current state (historical)

`IProjectionDefinition<TState>.Apply` receives the unwrapped `IEvent` payload, not the
full `SequencedEvent`:

```csharp
public interface IProjectionDefinition<TState> where TState : class
{
    string KeySelector(SequencedEvent evt);   // ✅ receives full context

    TState? Apply(TState? current, IEvent evt); // ❌ receives stripped payload only
}
```

Internally `ProjectionManager.ProjectionRegistration<TState>.ApplyAsync` unpacks the
event before calling the user's function:

```csharp
// ProjectionManager.cs — the unwrapping happens here
updated = _definition.Apply(current, evt.Event.Event);
//                                   ^^^^^^^^^^^^^^^ IEvent extracted from SequencedEvent
```

`IProjectionWithRelatedEvents<TState>` passes the same `IEvent` for its primary event,
even though the related events are full `SequencedEvent[]`:

```csharp
// IProjectionWithRelatedEvents — still passes IEvent for the primary event
TState? Apply(TState? current, IEvent evt, SequencedEvent[] relatedEvents);
```

### Why this matters

**Tags are inaccessible during `Apply`.** Tags are attached to `DomainEvent`
(`SequencedEvent.Event.Tags`), not to `IEvent`. A projection that needs to read a tag
value during `Apply` — for example to store a denormalised aggregate ID alongside the
projection state — cannot do so. The workaround is to duplicate the data inside the
`IEvent` payload itself, which violates the principle that tags are the domain's
indexing concern and the event body is the event's content.

**Metadata is inaccessible during `Apply`.** `SequencedEvent.Metadata` carries
`Timestamp`, `CorrelationId`, and `CausationId`. A projection that needs to track
"last modified at" or "last modified by" cannot read the timestamp or user ID without
embedding them redundantly in the event payload.

**Position is inaccessible during `Apply`.** While storing a raw position in projection
state is uncommon, there are legitimate uses — for example a projection that needs to
track the exact sequence position of the last event it processed for diagnostic purposes,
or a projection that implements its own watermarking independently of the checkpoint system.

**Asymmetry with `KeySelector`.** `KeySelector(SequencedEvent)` already has full access
to tags, metadata, and position. `Apply` having a weaker signature than `KeySelector`
is an arbitrary and surprising inconsistency for consumers learning the API.

**`IProjectionWithRelatedEvents` is inconsistent.** It passes `SequencedEvent[]` for
related events but `IEvent` for the primary event, meaning the primary event has less
context than the events fetched to support it. Fixing the base interface also fixes this.

### Proposed API

```csharp
public interface IProjectionDefinition<TState> where TState : class
{
    string ProjectionName { get; }
    string[] EventTypes { get; }

    string KeySelector(SequencedEvent evt);

    // Richer signature: full event context available in Apply
    TState? Apply(TState? current, SequencedEvent evt);
}
```

```csharp
public interface IProjectionWithRelatedEvents<TState>
    : IProjectionDefinition<TState> where TState : class
{
    Query? GetRelatedEventsQuery(SequencedEvent evt);  // also updated for consistency

    // Primary event is now SequencedEvent — consistent with relatedEvents
    TState? Apply(TState? current, SequencedEvent evt, SequencedEvent[] relatedEvents);

    TState? IProjectionDefinition<TState>.Apply(TState? current, SequencedEvent evt) =>
        throw new NotImplementedException(
            $"Projection {ProjectionName} uses related events — " +
            "the framework must call the overload with relatedEvents.");
}
```

Consumer migration is mechanical. Every existing `Apply` implementation changes
`IEvent evt` to `SequencedEvent evt` and accesses the payload via `evt.Event.Event`:

```csharp
// Before
public CourseShortInfo? Apply(CourseShortInfo? current, IEvent evt)
{
    return evt switch
    {
        CourseCreatedEvent e => new CourseShortInfo(e.CourseId, e.Title),
        _ => current
    };
}

// After — payload is one property deeper; tags and metadata now available if needed
public CourseShortInfo? Apply(CourseShortInfo? current, SequencedEvent evt)
{
    return evt.Event.Event switch
    {
        CourseCreatedEvent e => new CourseShortInfo(e.CourseId, e.Title),
        _ => current
    };
}
```

Internally, `ProjectionManager.ProjectionRegistration<TState>.ApplyAsync` stops
unwrapping and passes the full `SequencedEvent` directly:

```csharp
// Before
updated = _definition.Apply(current, evt.Event.Event);

// After
updated = _definition.Apply(current, evt);
```

### Implementation considerations

- The change to `ProjectionManager.ApplyAsync` is a single line.
- All projections in the sample application (`CourseShortInfoProjection`,
  `CourseDetailsProjection`, `CourseEnrollmentProjections`) and test projections must
  be updated — a mechanical find-and-replace.
- The `IProjectionWithRelatedEvents.GetRelatedEventsQuery` currently receives `IEvent`
  — this should be updated to `SequencedEvent` at the same time for full consistency.
- No storage format or on-disk representation changes; this is a pure in-memory API change.

### Breaking impact

- `IProjectionDefinition<TState>.Apply` signature changes from `(TState?, IEvent)` to
  `(TState?, SequencedEvent)`.
- `IProjectionWithRelatedEvents<TState>.Apply` and `GetRelatedEventsQuery` signatures change.
- Every projection implementation in the codebase — library tests, sample app — must be
  updated. The migration is mechanical but not zero-cost.

---

## 5. `Tag`, `QueryItem`, `Metadata`, `DomainEvent`, and `SequencedEvent` as Immutable `record` Types

> ✅ **DONE** — shipped in this session.

All core read-side types are now immutable C# `record`s with `init`-only properties.
Use `with` expressions to derive modified copies. Existing positional construction
and property-init syntax is unchanged. All 801 tests updated and passing.

**Files changed:** `Tag.cs`, `QueryItem.cs`, `Metadata.cs`, `DomainEvent.cs`,
`SequencedEvent.cs` — plus test suite migration across
`IndexManagerTests`, `EventFileManagerTests`, `FileSystemEventStoreTests`,
`FileSystemEventStoreReadTests`, `JsonEventSerializerTests`,
`ProjectionWithRelatedEventsTests` (unit + integration), `ProjectionEndToEndTests`,
`ParallelRebuildTests`, `ProjectionRebuildTests`, `AppendBenchmarks`,
`BenchmarkDataGenerator`, and `ProjectionServiceCollectionExtensionsTests`.

---

## 7. `IEventStoreMaintenance.AddTagsAsync` — Additive Tag Migration

> ✅ **DONE** — shipped in this session as a new feature request added mid-milestone.

Opossum now exposes `IEventStoreMaintenance` for strictly additive maintenance
operations. The only operation is `AddTagsAsync`, which retroactively adds tags to all
stored events of a given event type without modifying or deleting any existing tags.

**Key design decisions:**
- **Additive-only guarantee:** any requested tag whose key already exists on the event
  is silently skipped; no overwrite, no delete path exists.
- **Atomicity per event:** the append lock is acquired per-event so each file write and
  index update is atomic without blocking the entire migration.
- **DI registration:** `FileSystemEventStore` is registered once; both `IEventStore` and
  `IEventStoreMaintenance` resolve to the same singleton instance.
- **Result type:** `TagMigrationResult(int TagsAdded, int EventsProcessed)` gives callers
  a migration summary.

**New files:**
- `src/Opossum/IEventStoreMaintenance.cs`
- `src/Opossum/Core/TagMigrationResult.cs`
- `src/Opossum/Storage/FileSystem/FileSystemEventStore.Maintenance.cs`
- `tests/Opossum.UnitTests/Storage/FileSystem/EventStoreMaintenanceTests.cs` (9 tests)

**Modified files:**
- `src/Opossum/Storage/FileSystem/IndexManager.cs` — `AddTagsToIndexAsync`
- `src/Opossum/DependencyInjection/ServiceCollectionExtensions.cs` — dual registration

---

## Delivery order — prioritised

Items are grouped into three tiers. Items within the same tier are independent and can
be implemented in parallel; each tier should be fully merged before the next begins to
keep the main branch green.

### Tier 1 — Do first (small, self-contained, unblocks everything else)

| # | Item | Why first | Status |
|---|------|-----------|--------|
| 3 | **`Apply(SequencedEvent)` instead of `IEvent`** | Smallest change — one line in `ProjectionManager`, mechanical find-and-replace across all projections. Establishes the corrected projection contract that streaming reads and multi-context will build on. Zero risk to storage or read paths. | ✅ Done |
| 4 | **`CancellationToken` on `AppendAsync`** | One-parameter addition, breaking but trivial to migrate. Bundling it now avoids a fourth consecutive breaking release. Best done before multi-context adds more `AppendAsync` call sites that would also need updating. | ⬜ Pending |

### Tier 2 — Do second (stabilises `IEventStore`, moderate scope)

| # | Item | Why here | Status |
|---|------|----------|--------|
| 2 | **Streaming reads via `IAsyncEnumerable<SequencedEvent>`** | Changes the `IEventStore` return type once; all internal consumers (`ProjectionManager`, `ProjectionDaemon`, `DecisionModelExtensions`) are updated in the same pass. `CancellationToken` on `ReadAsync` is delivered as part of this change. After this the interface signature is stable for multi-context to build on. | ⬜ Pending |
| 5 | **`Tag` and `QueryItem` as immutable `record` types** | Fundamental types touched everywhere. Doing this immediately after the interface stabilises — and before multi-context multiplies usage sites — minimises churn. | ✅ Done |
| 7 | **`IEventStoreMaintenance.AddTagsAsync`** | Mid-milestone addition. Additive API — no breaking impact. Shipped alongside item 5 since both touch the core type surface. | ✅ Done |

### Tier 3 — Do third (architectural, builds on stabilised API)

| # | Item | Why here | Status |
|---|------|----------|--------|
| 1 | **Multi-context support** | Largest change. Requires the streaming `IEventStore` signature from Tier 2. Per-context `SemaphoreSlim` (via `ConcurrentDictionary`), `StorageInitializer` (already capable), `ProjectionManager`, `ProjectionDaemon`, and `ContextNotFoundException` all slot in on top of the stabilised foundation. | ⬜ Pending |
| 6 | **Extract `TagIndex`/`EventTypeIndex` duplication** | Pure internal refactor. Safest to do after multi-context since that change touches the index files and may surface more duplication to consolidate in one pass. No public API impact. | ⬜ Pending |

### Recommended commit sequence

```
1. Apply(SequencedEvent)             → IProjectionDefinition, IProjectionWithRelatedEvents,  ✅ DONE
                                       ProjectionManager (1 line), all projection impls
4a. Immutable record types           → Tag, QueryItem, Metadata, DomainEvent,              ✅ DONE
                                       SequencedEvent — all init-only; test suite migrated
4b. AddTagsAsync                     → IEventStoreMaintenance, TagMigrationResult,         ✅ DONE
                                       FileSystemEventStore.Maintenance, IndexManager,
                                       ServiceCollectionExtensions, 9 new tests
2. CancellationToken on AppendAsync  → IEventStore, FileSystemEventStore, all callers
3. IAsyncEnumerable ReadAsync        → IEventStore, FileSystemEventStore, EventFileManager,
                                       DecisionModelExtensions, ProjectionManager,
                                       ProjectionDaemon, EventStoreExtensions
5. Multi-context support             → FileSystemEventStore, ProjectionManager,
                                       ProjectionDaemon, retire mvp-single-context.md,
                                       add multi-context usage guide
6. Extract TagIndex/EventTypeIndex   → internal refactor + regression tests
```

## Deferred backlog

> **Promoted to milestone:** `CancellationToken` on `AppendAsync`, `Tag`/`QueryItem` records,
> and `TagIndex`/`EventTypeIndex` extraction are no longer deferred — see Tiers 1–3 above.

| Priority | Item | Why deferred |
|----------|------|--------------|
| ✅ Resolved | Metadata mutation side-effect in `AppendAsync` | Resolved as part of making `Metadata`, `DomainEvent`, and `SequencedEvent` immutable `record` types — `AppendAsync` now creates a new `Metadata` instance with `Timestamp` defaulted to `UtcNow` instead of mutating the caller’s object. |

> **Moved to 0.4.0:** Cache compiled delegate in `ReflectionMessageHandler` — performance
> work that does not touch any 0.3.0 API surface and carries non-trivial implementation risk.
> See [0.4.0 roadmap](./0.4.0-roadmap.md).
