# Opossum 0.3.0-preview.1 ‚Äî Release Roadmap

> **Status:** Planning
> **Target release:** 0.3.0-preview.1
> **Builds on:** 0.2.0-preview.1 (full DCB compliance, Decision Model projection layer)

This document captures the three planned improvements for the 0.3.0-preview.1 milestone,
with detailed reasoning for why each is worth tackling before a stable 1.0.0 release.
All three are **API-level changes** ‚Äî each one produces at least one breaking change ‚Äî which
is why they are grouped into a dedicated pre-release rather than cherry-picked into a patch.

---

## Overview

| # | Feature | Breaking? | Effort |
|---|---------|-----------|--------|
| 1 | [Multi-context support](#1-multi-context-support) | Yes ‚Äî new parameter on `ReadAsync` / `AppendAsync` | Large |
| 2 | [Streaming reads via `IAsyncEnumerable<SequencedEvent>`](#2-streaming-reads-via-iasyncenumerablesequencedevent) | Yes ‚Äî `IEventStore.ReadAsync` return type changes | Medium |
| 3 | [`Apply` receives `SequencedEvent` instead of `IEvent`](#3-apply-receives-sequencedevent-instead-of-ievent) | Yes ‚Äî `IProjectionDefinition<TState>` signature changes | Small |

All three should ship together in 0.3.0 to avoid asking consumers to absorb three
consecutive breaking releases.

---

## 1. Multi-context Support

### Current state

`FileSystemEventStore.AppendAsync` and `ReadAsync` both hard-code `_options.Contexts[0]`
for every operation:

```csharp
// FileSystemEventStore ‚Äî same pattern in AppendAsync and ReadAsync
// MVP LIMITATION: Only Contexts[0] is used. Multi-context support planned for future release.
var contextPath = GetContextPath(_options.Contexts[0]);
```

`ProjectionManager` makes the same assumption:

```csharp
// ProjectionManager constructor
var contextPath = Path.Combine(options.RootPath, options.Contexts[0]);
_checkpointPath = Path.Combine(contextPath, "Projections", "_checkpoints");
```

`OpossumOptions.Contexts` is already a `List<string>` and `AddContext()` works, but any
context beyond the first is silently ignored ‚Äî a potential source of hard-to-diagnose bugs
for consumers who call `AddContext` more than once expecting isolation.

### Why this matters

**Bounded context isolation** is one of the core use cases that motivates a separate
event store per context. Without it, a single Opossum instance can only model one
bounded context at a time. In real-world deployments this forces consumers to either:

1. **Run multiple processes** ‚Äî one per bounded context ‚Äî with all the associated
   operational overhead (separate config, separate deployments, separate monitoring).
2. **Conflate all contexts into one** ‚Äî mixing `CourseManagement` and `Billing` events
   into the same ledger, losing isolation and making queries noisier.

Example: an on-premises ERP covering `Sales`, `Inventory`, and `Billing` cannot use a
single Opossum instance today. The workaround is three separate root paths and three
separate service registrations, which is both wasteful and error-prone.

Multi-context support is also required before any tag-routing optimisation: the store
needs to know *which* context a read or append targets before it can apply index lookups.

### Proposed API

The cleanest approach introduces context as an optional parameter rather than a mandatory
one, preserving backward compatibility for the single-context majority:

```csharp
public interface IEventStore
{
    // context defaults to the first (and only) registered context ‚Äî backward-compatible
    Task AppendAsync(NewEvent[] events, AppendCondition? condition, string? context = null);
    Task<SequencedEvent[]> ReadAsync(Query query, ReadOption[]? readOptions,
        long? fromPosition = null, string? context = null);
}
```

Extension methods keep the existing single-context call sites intact:

```csharp
// All existing callers continue to compile unchanged
await eventStore.AppendAsync(newEvent);
await eventStore.ReadAsync(Query.All());

// New multi-context callers opt in explicitly
await eventStore.AppendAsync(newEvent, condition, context: "Billing");
await eventStore.ReadAsync(Query.All(), context: "Inventory");
```

Internally, `FileSystemEventStore` resolves the context path as:

```csharp
private string ResolveContextPath(string? context)
{
    if (context == null)
        return GetContextPath(_options.Contexts[0]);

    if (!_options.Contexts.Contains(context))
        throw new ContextNotFoundException($"Context '{context}' is not configured.", context);

    return GetContextPath(context);
}
```

`ProjectionManager` needs a corresponding `context` parameter on `RegisterProjection`,
`RebuildAsync`, and `UpdateAsync` so projections can be scoped to a specific context.

### Implementation considerations

- The `StorageInitializer` already creates directories per context name ‚Äî the storage
  layout is already multi-context-capable.
- The semaphore in `FileSystemEventStore` is currently shared across all appends. With
  multiple contexts, each context should have its own `SemaphoreSlim` to avoid unnecessary
  serialisation of appends to unrelated contexts. A `ConcurrentDictionary<string, SemaphoreSlim>`
  keyed by context name is the natural fit.
- `ProjectionDaemon` currently polls `Query.All()` globally. With multiple contexts it
  must poll each registered context separately or accept a context parameter.
- The existing `ContextNotFoundException` is already defined and ready to use.
- The `docs/limitations/mvp-single-context.md` limitation document should be retired
  and replaced with a multi-context usage guide.

### Breaking impact

- `IEventStore.AppendAsync` and `ReadAsync` gain a new optional `context` parameter.
  All existing call sites continue to compile; no forced migration for single-context users.
- `IProjectionManager` gains `context` parameters on projection registration and rebuild.

---

## 2. Streaming Reads via `IAsyncEnumerable<SequencedEvent>`

### Current state

`IEventStore.ReadAsync` materialises the entire result set into an array before returning:

```csharp
public async Task<SequencedEvent[]> ReadAsync(Query query, ReadOption[]? readOptions,
    long? fromPosition = null)
{
    // ...
    var positions = await GetPositionsForQueryAsync(contextPath, query, fromPosition)
        .ConfigureAwait(false);

    // All positions read into memory before the first event is returned to the caller
    var events = await _eventFileManager.ReadEventsAsync(eventsPath, positions)
        .ConfigureAwait(false);

    return events;
}
```

`EventFileManager.ReadEventsAsync` reads each event file in a loop and collects results
into a `List<SequencedEvent>` before converting to an array. Each event is a separate
JSON file on disk, read sequentially ‚Äî the work is inherently incremental, but the API
forces complete materialisation.

### Why this matters

**Memory pressure on large reads.** An event log with 500,000 matching events at an
average of 1 KB per event payload occupies ~500 MB of heap before the caller processes
event number one. The current `SequencedEvent[]` model forces the caller to hold the
entire result in memory simultaneously.

**Latency to first event.** A projection rebuild that processes 1 million events cannot
start work until all 1 million events are deserialized. With `IAsyncEnumerable<SequencedEvent>`,
the projection's `Apply` function can be called as soon as the first event file is read ‚Äî
overlapping I/O and CPU work, and starting to produce output much sooner.

**Composability.** `IAsyncEnumerable<T>` integrates naturally with LINQ via
`System.Linq.Async`, with `Channel<T>`-based pipelines, and with `CancellationToken`
propagation. The current array model forces every consumer to either load everything
(expensive) or build their own chunking on top of `ReadAsync` + `fromPosition`.

**The DCB specification** acknowledges this concern explicitly:
> The Event Store SHOULD return events in "some form of iterable or reactive stream"
> rather than a fully materialised collection.

For the target deployment scale (‚â§ 10 M events, single server) the `SequencedEvent[]`
model is workable, but the longer this stays in place the more callers build
array-centric processing logic that will be harder to migrate later.

### Proposed API

```csharp
public interface IEventStore
{
    Task AppendAsync(NewEvent[] events, AppendCondition? condition, string? context = null);

    IAsyncEnumerable<SequencedEvent> ReadAsync(
        Query query,
        ReadOption[]? readOptions,
        long? fromPosition = null,
        string? context = null,
        CancellationToken cancellationToken = default);
}
```

Callers that need an array use `ToArrayAsync()` from `System.Linq.Async`
(or a simple helper extension):

```csharp
// Callers that need a full array (e.g. DecisionModelExtensions)
var events = await eventStore.ReadAsync(query).ToArrayAsync(ct);

// Callers that stream (e.g. ProjectionManager.RebuildAsync)
await foreach (var evt in eventStore.ReadAsync(Query.All(), fromPosition: checkpoint, ct))
{
    await registration.ApplyAsync(evt, ct);
}
```

A compatibility extension keeps the `Task<SequencedEvent[]>` call pattern for consumers
that cannot yet migrate:

```csharp
// Backward-compat shim in EventStoreExtensions
public static Task<SequencedEvent[]> ReadToArrayAsync(
    this IEventStore store,
    Query query,
    ReadOption[]? readOptions = null,
    long? fromPosition = null,
    CancellationToken cancellationToken = default)
    => store.ReadAsync(query, readOptions, fromPosition, cancellationToken: cancellationToken)
            .ToArrayAsync(cancellationToken)
            .AsTask();
```

### Implementation considerations

- `EventFileManager.ReadEventsAsync` can be changed to `IAsyncEnumerable<SequencedEvent>`
  by replacing the `List<SequencedEvent>` accumulator with `yield return` ‚Äî a minimal
  change to the innermost reader loop.
- `GetPositionsForQueryAsync` still returns a `long[]` (the index lookups are already
  fully in-memory). Only the event-file reading stage becomes lazy.
- The `Descending` read option is currently implemented by reversing the `positions` array
  before reading. This is still possible: reverse the positions array, then stream the
  reads in reversed order.
- All internal consumers (`DecisionModelExtensions`, `ProjectionManager.RebuildAsync`,
  `ProjectionDaemon`) must be updated to either call `.ToArrayAsync()` or adopt streaming.
  The projection rebuild path is the primary beneficiary ‚Äî streaming eliminates the
  "load all 500k events then iterate" pattern.
- `System.Linq.Async` is already available to .NET 10 projects via the BCL.

### Breaking impact

- `IEventStore.ReadAsync` return type changes from `Task<SequencedEvent[]>` to
  `IAsyncEnumerable<SequencedEvent>`. Every caller must add `await foreach` or `.ToArrayAsync()`.
- The existing `EventStoreExtensions.ReadAsync(query)` and `ReadAsync(query, ReadOption)`
  overloads must be updated or replaced with new signatures.
- This is the most invasive of the three changes. It should ship alongside the others
  so consumers absorb one migration rather than three.

---

## 3. `Apply` Receives `SequencedEvent` Instead of `IEvent`

### Current state

`IProjectionDefinition<TState>.Apply` receives the unwrapped `IEvent` payload, not the
full `SequencedEvent`:

```csharp
public interface IProjectionDefinition<TState> where TState : class
{
    string KeySelector(SequencedEvent evt);   // ‚úÖ receives full context

    TState? Apply(TState? current, IEvent evt); // ‚ùå receives stripped payload only
}
```

Internally `ProjectionManager.ProjectionRegistration<TState>.ApplyAsync` unpacks the
event before calling the user's function:

```csharp
// ProjectionManager.cs ‚Äî the unwrapping happens here
updated = _definition.Apply(current, evt.Event.Event);
//                                   ^^^^^^^^^^^^^^^ IEvent extracted from SequencedEvent
```

`IProjectionWithRelatedEvents<TState>` passes the same `IEvent` for its primary event,
even though the related events are full `SequencedEvent[]`:

```csharp
// IProjectionWithRelatedEvents ‚Äî still passes IEvent for the primary event
TState? Apply(TState? current, IEvent evt, SequencedEvent[] relatedEvents);
```

### Why this matters

**Tags are inaccessible during `Apply`.** Tags are attached to `DomainEvent`
(`SequencedEvent.Event.Tags`), not to `IEvent`. A projection that needs to read a tag
value during `Apply` ‚Äî for example to store a denormalised aggregate ID alongside the
projection state ‚Äî cannot do so. The workaround is to duplicate the data inside the
`IEvent` payload itself, which violates the principle that tags are the domain's
indexing concern and the event body is the event's content.

**Metadata is inaccessible during `Apply`.** `SequencedEvent.Metadata` carries
`Timestamp`, `CorrelationId`, and `CausationId`. A projection that needs to track
"last modified at" or "last modified by" cannot read the timestamp or user ID without
embedding them redundantly in the event payload.

**Position is inaccessible during `Apply`.** While storing a raw position in projection
state is uncommon, there are legitimate uses ‚Äî for example a projection that needs to
track the exact sequence position of the last event it processed for diagnostic purposes,
or a projection that implements its own watermarking independently of the checkpoint system.

**Asymmetry with `KeySelector`.** `KeySelector(SequencedEvent)` already has full access
to tags, metadata, and position. `Apply` having a weaker signature than `KeySelector`
is an arbitrary and surprising inconsistency for consumers learning the API.

**`IProjectionWithRelatedEvents` is inconsistent.** It passes `SequencedEvent[]` for
related events but `IEvent` for the primary event, meaning the primary event has less
context than the events fetched to support it. Fixing the base interface also fixes this.

### Proposed API

```csharp
public interface IProjectionDefinition<TState> where TState : class
{
    string ProjectionName { get; }
    string[] EventTypes { get; }

    string KeySelector(SequencedEvent evt);

    // Richer signature: full event context available in Apply
    TState? Apply(TState? current, SequencedEvent evt);
}
```

```csharp
public interface IProjectionWithRelatedEvents<TState>
    : IProjectionDefinition<TState> where TState : class
{
    Query? GetRelatedEventsQuery(SequencedEvent evt);  // also updated for consistency

    // Primary event is now SequencedEvent ‚Äî consistent with relatedEvents
    TState? Apply(TState? current, SequencedEvent evt, SequencedEvent[] relatedEvents);

    TState? IProjectionDefinition<TState>.Apply(TState? current, SequencedEvent evt) =>
        throw new NotImplementedException(
            $"Projection {ProjectionName} uses related events ‚Äî " +
            "the framework must call the overload with relatedEvents.");
}
```

Consumer migration is mechanical. Every existing `Apply` implementation changes
`IEvent evt` to `SequencedEvent evt` and accesses the payload via `evt.Event.Event`:

```csharp
// Before
public CourseShortInfo? Apply(CourseShortInfo? current, IEvent evt)
{
    return evt switch
    {
        CourseCreatedEvent e => new CourseShortInfo(e.CourseId, e.Title),
        _ => current
    };
}

// After ‚Äî payload is one property deeper; tags and metadata now available if needed
public CourseShortInfo? Apply(CourseShortInfo? current, SequencedEvent evt)
{
    return evt.Event.Event switch
    {
        CourseCreatedEvent e => new CourseShortInfo(e.CourseId, e.Title),
        _ => current
    };
}
```

Internally, `ProjectionManager.ProjectionRegistration<TState>.ApplyAsync` stops
unwrapping and passes the full `SequencedEvent` directly:

```csharp
// Before
updated = _definition.Apply(current, evt.Event.Event);

// After
updated = _definition.Apply(current, evt);
```

### Implementation considerations

- The change to `ProjectionManager.ApplyAsync` is a single line.
- All projections in the sample application (`CourseShortInfoProjection`,
  `CourseDetailsProjection`, `CourseEnrollmentProjections`) and test projections must
  be updated ‚Äî a mechanical find-and-replace.
- The `IProjectionWithRelatedEvents.GetRelatedEventsQuery` currently receives `IEvent`
  ‚Äî this should be updated to `SequencedEvent` at the same time for full consistency.
- No storage format or on-disk representation changes; this is a pure in-memory API change.

### Breaking impact

- `IProjectionDefinition<TState>.Apply` signature changes from `(TState?, IEvent)` to
  `(TState?, SequencedEvent)`.
- `IProjectionWithRelatedEvents<TState>.Apply` and `GetRelatedEventsQuery` signatures change.
- Every projection implementation in the codebase ‚Äî library tests, sample app ‚Äî must be
  updated. The migration is mechanical but not zero-cost.

---

## Delivery order

The three items are independent of one another and can be implemented in parallel, but the
recommended sequencing within the milestone is:

1. **`Apply(SequencedEvent)` first** ‚Äî smallest change, entirely within the projection
   layer, zero risk to the storage or read paths. Establishes the corrected contract
   that streaming reads and multi-context support will build on.

2. **Streaming reads second** ‚Äî changes `IEventStore` but not the storage format.
   Once done, `ProjectionManager.RebuildAsync` and `ProjectionDaemon` can adopt
   `await foreach` immediately, which reduces their heap footprint before multi-context
   support multiplies the number of contexts being processed.

3. **Multi-context last** ‚Äî builds on the stabilised `IEventStore` signature produced
   by step 2. Routing logic, per-context semaphores, and projection scoping can all be
   added on top of the streaming-capable store without further signature churn.

Deferred backlog (recommended for 0.3.0)
Priority	Item	Why deferred
üî¥	Add CancellationToken to AppendAsync(NewEvent[], AppendCondition?) and ReadAsync(Query, ReadOption[]?, long?)	Breaking change ‚Äî needs a version bump
üü†	Make Tag and QueryItem immutable record types	Breaking change
üü†	Extract duplicated TagIndex/EventTypeIndex code to a shared utility	Refactor scope, risk of subtle regression
üü°	Cache compiled delegate in ReflectionMessageHandler	Meaningful for high-throughput mediator; non-trivial
üü°	Metadata mutation in AppendAsync(NewEvent[], AppendCondition?) is surprising	Requires API design decision
