# Opossum 0.3.0-preview.1 ‚Äî Release Roadmap

> **Status:** In Progress
> **Target release:** 0.3.0-preview.1
> **Builds on:** 0.2.0-preview.1 (full DCB compliance, Decision Model projection layer)

This document captures the six planned improvements for the 0.3.0-preview.1 milestone.
The first three are the originally-scoped **API-level breaking changes**; items 4‚Äì6 were
previously listed as deferred backlog candidates and have been **promoted into this milestone**
after prioritisation. All breaking changes are grouped into a single pre-release to avoid
asking consumers to absorb multiple consecutive breaking releases.

A seventh item ‚Äî `IEventStoreMaintenance.AddTagsAsync` ‚Äî was added mid-milestone as a
new feature request. It shipped alongside item 5 (immutable types).

---

## Overview

All six items ship together in 0.3.0. Items 4‚Äì6 were originally deferred; they have been
promoted after prioritisation because bundling them now avoids additional breaking releases.

| Tier | # | Feature | Breaking? | Effort | Status |
|------|---|---------|-----------|--------|--------|
| 1 | 3 | [`Apply` receives `SequencedEvent` instead of `IEvent`](#3-apply-receives-sequencedevent-instead-of-ievent) | Yes ‚Äî `IProjectionDefinition<TState>` signature changes | Small | ‚úÖ Done |
| 1 | 4 | `CancellationToken` on `AppendAsync(NewEvent[], AppendCondition?)` | Yes ‚Äî new parameter | Small | ‚úÖ Done |
| 2 | 2 | [Streaming reads via `IAsyncEnumerable<SequencedEvent>`](#2-streaming-reads-via-iasyncenumerablesequencedevent) | N/A ‚Äî decision not to implement | ‚Äî | ‚ùå Will Not Implement |
| 2 | 5 | `Tag` and `QueryItem` as immutable `record` types | Yes ‚Äî construction syntax changes | Small | ‚úÖ Done |
| 2 | 7 | [`IEventStoreMaintenance.AddTagsAsync` ‚Äî additive tag migration](#7-ieventstoretenanceaddtagsasync) | No ‚Äî additive API | Small | ‚úÖ Done |
| 3 | 1 | [Multi-context support](#1-multi-context-support) | N/A ‚Äî decision not to implement | ‚Äî | ‚ùå Will Not Implement |
| 3 | 6 | Extract `TagIndex`/`EventTypeIndex` duplication to a shared utility | No ‚Äî internal refactor | Small | ‚úÖ Done |
| 3 | 8 | [`AddContext` ‚Üí `UseStore` rename; `Contexts` list ‚Üí `StoreName` property](#8-addcontext--usestore-rename) | Yes ‚Äî API rename | Small | ‚úÖ Done |

---

## 1. Multi-context Support

> ‚ùå **WILL NOT IMPLEMENT** ‚Äî decided after evaluating Opossum's deployment profile. See
> [ADR-004](../decisions/004-single-context-by-design.md) for the full reasoning.
>
> **Summary:** Multi-context-in-one-process is a cloud-era modular monolith pattern. It solves
> a problem that does not exist for Opossum's target users (POS, field service, SMB, offline-first),
> where each deployed application models exactly one bounded context. The implementation
> complexity ‚Äî per-context semaphores, projection scoping, daemon polling loops ‚Äî is
> disproportionate to the benefit. Consumers who need two isolated event streams can register
> two `IEventStore` instances with different root paths via standard .NET keyed services.
> This item is closed and is not on any future roadmap.

### Current state (historical)

`FileSystemEventStore.AppendAsync` and `ReadAsync` both hard-code `_options.Contexts[0]`
for every operation:

```csharp
// FileSystemEventStore ‚Äî same pattern in AppendAsync and ReadAsync
// MVP LIMITATION: Only Contexts[0] is used. Multi-context support planned for future release.
var contextPath = GetContextPath(_options.Contexts[0]);
```

`ProjectionManager` makes the same assumption:

```csharp
// ProjectionManager constructor
var contextPath = Path.Combine(options.RootPath, options.Contexts[0]);
_checkpointPath = Path.Combine(contextPath, "Projections", "_checkpoints");
```

`OpossumOptions.Contexts` is already a `List<string>` and `AddContext()` works, but any
context beyond the first is silently ignored ‚Äî a potential source of hard-to-diagnose bugs
for consumers who call `AddContext` more than once expecting isolation.

### Why this matters

**Bounded context isolation** is one of the core use cases that motivates a separate
event store per context. Without it, a single Opossum instance can only model one
bounded context at a time. In real-world deployments this forces consumers to either:

1. **Run multiple processes** ‚Äî one per bounded context ‚Äî with all the associated
   operational overhead (separate config, separate deployments, separate monitoring).
2. **Conflate all contexts into one** ‚Äî mixing `CourseManagement` and `Billing` events
   into the same ledger, losing isolation and making queries noisier.

Example: an on-premises ERP covering `Sales`, `Inventory`, and `Billing` cannot use a
single Opossum instance today. The workaround is three separate root paths and three
separate service registrations, which is both wasteful and error-prone.

Multi-context support is also required before any tag-routing optimisation: the store
needs to know *which* context a read or append targets before it can apply index lookups.

### Proposed API

The cleanest approach introduces context as an optional parameter rather than a mandatory
one, preserving backward compatibility for the single-context majority:

```csharp
public interface IEventStore
{
    // context defaults to the first (and only) registered context ‚Äî backward-compatible
    Task AppendAsync(NewEvent[] events, AppendCondition? condition, string? context = null);
    Task<SequencedEvent[]> ReadAsync(Query query, ReadOption[]? readOptions,
        long? fromPosition = null, string? context = null);
}
```

Extension methods keep the existing single-context call sites intact:

```csharp
// All existing callers continue to compile unchanged
await eventStore.AppendAsync(newEvent);
await eventStore.ReadAsync(Query.All());

// New multi-context callers opt in explicitly
await eventStore.AppendAsync(newEvent, condition, context: "Billing");
await eventStore.ReadAsync(Query.All(), context: "Inventory");
```

Internally, `FileSystemEventStore` resolves the context path as:

```csharp
private string ResolveContextPath(string? context)
{
    if (context == null)
        return GetContextPath(_options.Contexts[0]);

    if (!_options.Contexts.Contains(context))
        throw new ContextNotFoundException($"Context '{context}' is not configured.", context);

    return GetContextPath(context);
}
```

`ProjectionManager` needs a corresponding `context` parameter on `RegisterProjection`,
`RebuildAsync`, and `UpdateAsync` so projections can be scoped to a specific context.

### Implementation considerations

- The `StorageInitializer` already creates directories per context name ‚Äî the storage
  layout is already multi-context-capable.
- The semaphore in `FileSystemEventStore` is currently shared across all appends. With
  multiple contexts, each context should have its own `SemaphoreSlim` to avoid unnecessary
  serialisation of appends to unrelated contexts. A `ConcurrentDictionary<string, SemaphoreSlim>`
  keyed by context name is the natural fit.
- `ProjectionDaemon` currently polls `Query.All()` globally. With multiple contexts it
  must poll each registered context separately or accept a context parameter.
- The existing `ContextNotFoundException` is already defined and ready to use.
- The `docs/limitations/mvp-single-context.md` limitation document should be retired
  and replaced with a multi-context usage guide.

### Breaking impact

- `IEventStore.AppendAsync` and `ReadAsync` gain a new optional `context` parameter.
  All existing call sites continue to compile; no forced migration for single-context users.
- `IProjectionManager` gains `context` parameters on projection registration and rebuild.

---

## 2. Streaming Reads via `IAsyncEnumerable<SequencedEvent>`

> ‚ùå **WILL NOT IMPLEMENT** ‚Äî decided after detailed analysis. See
> [ADR-003](../decisions/003-iasyncenumerable-not-implemented.md) for the full reasoning.
>
> **Summary:** The parallel I/O optimisation (`Parallel.ForEachAsync`) that drove the
> 3-hour ‚Üí 18-minute projection rebuild improvement is incompatible with a naive sequential
> streaming model. A correct ordered parallel-prefetch implementation is disproportionately
> complex for Opossum's target deployment profile (single server, POS, offline-first).
> `IEventStore.ReadAsync` keeps `Task<SequencedEvent[]>`. If memory pressure from large
> rebuilds is ever reported, the fix is chunked reading inside `ProjectionManager`, not
> a public API change. This item is closed and is not on any future roadmap.

### Current state (historical)

`IEventStore.ReadAsync` materialises the entire result set into an array before returning:

```csharp
public async Task<SequencedEvent[]> ReadAsync(Query query, ReadOption[]? readOptions,
    long? fromPosition = null)
{
    // ...
    var positions = await GetPositionsForQueryAsync(contextPath, query, fromPosition)
        .ConfigureAwait(false);

    // All positions read into memory before the first event is returned to the caller
    var events = await _eventFileManager.ReadEventsAsync(eventsPath, positions)
        .ConfigureAwait(false);

    return events;
}
```

`EventFileManager.ReadEventsAsync` reads each event file in a loop and collects results
into a `List<SequencedEvent>` before converting to an array. Each event is a separate
JSON file on disk, read sequentially ‚Äî the work is inherently incremental, but the API
forces complete materialisation.

### Why this matters

**Memory pressure on large reads.** An event log with 500,000 matching events at an
average of 1 KB per event payload occupies ~500 MB of heap before the caller processes
event number one. The current `SequencedEvent[]` model forces the caller to hold the
entire result in memory simultaneously.

**Latency to first event.** A projection rebuild that processes 1 million events cannot
start work until all 1 million events are deserialized. With `IAsyncEnumerable<SequencedEvent>`,
the projection's `Apply` function can be called as soon as the first event file is read ‚Äî
overlapping I/O and CPU work, and starting to produce output much sooner.

**Composability.** `IAsyncEnumerable<T>` integrates naturally with LINQ via
`System.Linq.Async`, with `Channel<T>`-based pipelines, and with `CancellationToken`
propagation. The current array model forces every consumer to either load everything
(expensive) or build their own chunking on top of `ReadAsync` + `fromPosition`.

**The DCB specification** acknowledges this concern explicitly:
> The Event Store SHOULD return events in "some form of iterable or reactive stream"
> rather than a fully materialised collection.

For the target deployment scale (‚â§ 10 M events, single server) the `SequencedEvent[]`
model is workable, but the longer this stays in place the more callers build
array-centric processing logic that will be harder to migrate later.

### Proposed API

```csharp
public interface IEventStore
{
    Task AppendAsync(NewEvent[] events, AppendCondition? condition, string? context = null);

    IAsyncEnumerable<SequencedEvent> ReadAsync(
        Query query,
        ReadOption[]? readOptions,
        long? fromPosition = null,
        string? context = null,
        CancellationToken cancellationToken = default);
}
```

Callers that need an array use `ToArrayAsync()` from `System.Linq.Async`
(or a simple helper extension):

```csharp
// Callers that need a full array (e.g. DecisionModelExtensions)
var events = await eventStore.ReadAsync(query).ToArrayAsync(ct);

// Callers that stream (e.g. ProjectionManager.RebuildAsync)
await foreach (var evt in eventStore.ReadAsync(Query.All(), fromPosition: checkpoint, ct))
{
    await registration.ApplyAsync(evt, ct);
}
```

A compatibility extension keeps the `Task<SequencedEvent[]>` call pattern for consumers
that cannot yet migrate:

```csharp
// Backward-compat shim in EventStoreExtensions
public static Task<SequencedEvent[]> ReadToArrayAsync(
    this IEventStore store,
    Query query,
    ReadOption[]? readOptions = null,
    long? fromPosition = null,
    CancellationToken cancellationToken = default)
    => store.ReadAsync(query, readOptions, fromPosition, cancellationToken: cancellationToken)
            .ToArrayAsync(cancellationToken)
            .AsTask();
```

### Implementation considerations

- `EventFileManager.ReadEventsAsync` can be changed to `IAsyncEnumerable<SequencedEvent>`
  by replacing the `List<SequencedEvent>` accumulator with `yield return` ‚Äî a minimal
  change to the innermost reader loop.
- `GetPositionsForQueryAsync` still returns a `long[]` (the index lookups are already
  fully in-memory). Only the event-file reading stage becomes lazy.
- The `Descending` read option is currently implemented by reversing the `positions` array
  before reading. This is still possible: reverse the positions array, then stream the
  reads in reversed order.
- All internal consumers (`DecisionModelExtensions`, `ProjectionManager.RebuildAsync`,
  `ProjectionDaemon`) must be updated to either call `.ToArrayAsync()` or adopt streaming.
  The projection rebuild path is the primary beneficiary ‚Äî streaming eliminates the
  "load all 500k events then iterate" pattern.
- `System.Linq.Async` is already available to .NET 10 projects via the BCL.

### Breaking impact

- `IEventStore.ReadAsync` return type changes from `Task<SequencedEvent[]>` to
  `IAsyncEnumerable<SequencedEvent>`. Every caller must add `await foreach` or `.ToArrayAsync()`.
- The existing `EventStoreExtensions.ReadAsync(query)` and `ReadAsync(query, ReadOption)`
  overloads must be updated or replaced with new signatures.
- This is the most invasive of the three changes. It should ship alongside the others
  so consumers absorb one migration rather than three.

---

## 3. `Apply` Receives `SequencedEvent` Instead of `IEvent`

> ‚úÖ **DONE** ‚Äî shipped in this session. All projection `Apply` and `GetRelatedEventsQuery`
> signatures updated. All callers (library, tests, sample app) migrated. 801/801 tests pass.

### Current state (historical)

`IProjectionDefinition<TState>.Apply` receives the unwrapped `IEvent` payload, not the
full `SequencedEvent`:

```csharp
public interface IProjectionDefinition<TState> where TState : class
{
    string KeySelector(SequencedEvent evt);   // ‚úÖ receives full context

    TState? Apply(TState? current, IEvent evt); // ‚ùå receives stripped payload only
}
```

Internally `ProjectionManager.ProjectionRegistration<TState>.ApplyAsync` unpacks the
event before calling the user's function:

```csharp
// ProjectionManager.cs ‚Äî the unwrapping happens here
updated = _definition.Apply(current, evt.Event.Event);
//                                   ^^^^^^^^^^^^^^^ IEvent extracted from SequencedEvent
```

`IProjectionWithRelatedEvents<TState>` passes the same `IEvent` for its primary event,
even though the related events are full `SequencedEvent[]`:

```csharp
// IProjectionWithRelatedEvents ‚Äî still passes IEvent for the primary event
TState? Apply(TState? current, IEvent evt, SequencedEvent[] relatedEvents);
```

### Why this matters

**Tags are inaccessible during `Apply`.** Tags are attached to `DomainEvent`
(`SequencedEvent.Event.Tags`), not to `IEvent`. A projection that needs to read a tag
value during `Apply` ‚Äî for example to store a denormalised aggregate ID alongside the
projection state ‚Äî cannot do so. The workaround is to duplicate the data inside the
`IEvent` payload itself, which violates the principle that tags are the domain's
indexing concern and the event body is the event's content.

**Metadata is inaccessible during `Apply`.** `SequencedEvent.Metadata` carries
`Timestamp`, `CorrelationId`, and `CausationId`. A projection that needs to track
"last modified at" or "last modified by" cannot read the timestamp or user ID without
embedding them redundantly in the event payload.

**Position is inaccessible during `Apply`.** While storing a raw position in projection
state is uncommon, there are legitimate uses ‚Äî for example a projection that needs to
track the exact sequence position of the last event it processed for diagnostic purposes,
or a projection that implements its own watermarking independently of the checkpoint system.

**Asymmetry with `KeySelector`.** `KeySelector(SequencedEvent)` already has full access
to tags, metadata, and position. `Apply` having a weaker signature than `KeySelector`
is an arbitrary and surprising inconsistency for consumers learning the API.

**`IProjectionWithRelatedEvents` is inconsistent.** It passes `SequencedEvent[]` for
related events but `IEvent` for the primary event, meaning the primary event has less
context than the events fetched to support it. Fixing the base interface also fixes this.

### Proposed API

```csharp
public interface IProjectionDefinition<TState> where TState : class
{
    string ProjectionName { get; }
    string[] EventTypes { get; }

    string KeySelector(SequencedEvent evt);

    // Richer signature: full event context available in Apply
    TState? Apply(TState? current, SequencedEvent evt);
}
```

```csharp
public interface IProjectionWithRelatedEvents<TState>
    : IProjectionDefinition<TState> where TState : class
{
    Query? GetRelatedEventsQuery(SequencedEvent evt);  // also updated for consistency

    // Primary event is now SequencedEvent ‚Äî consistent with relatedEvents
    TState? Apply(TState? current, SequencedEvent evt, SequencedEvent[] relatedEvents);

    TState? IProjectionDefinition<TState>.Apply(TState? current, SequencedEvent evt) =>
        throw new NotImplementedException(
            $"Projection {ProjectionName} uses related events ‚Äî " +
            "the framework must call the overload with relatedEvents.");
}
```

Consumer migration is mechanical. Every existing `Apply` implementation changes
`IEvent evt` to `SequencedEvent evt` and accesses the payload via `evt.Event.Event`:

```csharp
// Before
public CourseShortInfo? Apply(CourseShortInfo? current, IEvent evt)
{
    return evt switch
    {
        CourseCreatedEvent e => new CourseShortInfo(e.CourseId, e.Title),
        _ => current
    };
}

// After ‚Äî payload is one property deeper; tags and metadata now available if needed
public CourseShortInfo? Apply(CourseShortInfo? current, SequencedEvent evt)
{
    return evt.Event.Event switch
    {
        CourseCreatedEvent e => new CourseShortInfo(e.CourseId, e.Title),
        _ => current
    };
}
```

Internally, `ProjectionManager.ProjectionRegistration<TState>.ApplyAsync` stops
unwrapping and passes the full `SequencedEvent` directly:

```csharp
// Before
updated = _definition.Apply(current, evt.Event.Event);

// After
updated = _definition.Apply(current, evt);
```

### Implementation considerations

- The change to `ProjectionManager.ApplyAsync` is a single line.
- All projections in the sample application (`CourseShortInfoProjection`,
  `CourseDetailsProjection`, `CourseEnrollmentProjections`) and test projections must
  be updated ‚Äî a mechanical find-and-replace.
- The `IProjectionWithRelatedEvents.GetRelatedEventsQuery` currently receives `IEvent`
  ‚Äî this should be updated to `SequencedEvent` at the same time for full consistency.
- No storage format or on-disk representation changes; this is a pure in-memory API change.

### Breaking impact

- `IProjectionDefinition<TState>.Apply` signature changes from `(TState?, IEvent)` to
  `(TState?, SequencedEvent)`.
- `IProjectionWithRelatedEvents<TState>.Apply` and `GetRelatedEventsQuery` signatures change.
- Every projection implementation in the codebase ‚Äî library tests, sample app ‚Äî must be
  updated. The migration is mechanical but not zero-cost.

---

## 5. `Tag`, `QueryItem`, `Metadata`, `DomainEvent`, and `SequencedEvent` as Immutable `record` Types

> ‚úÖ **DONE** ‚Äî shipped in this session.

All core read-side types are now immutable C# `record`s with `init`-only properties.
Use `with` expressions to derive modified copies. Existing positional construction
and property-init syntax is unchanged. All 801 tests updated and passing.

**Files changed:** `Tag.cs`, `QueryItem.cs`, `Metadata.cs`, `DomainEvent.cs`,
`SequencedEvent.cs` ‚Äî plus test suite migration across
`IndexManagerTests`, `EventFileManagerTests`, `FileSystemEventStoreTests`,
`FileSystemEventStoreReadTests`, `JsonEventSerializerTests`,
`ProjectionWithRelatedEventsTests` (unit + integration), `ProjectionEndToEndTests`,
`ParallelRebuildTests`, `ProjectionRebuildTests`, `AppendBenchmarks`,
`BenchmarkDataGenerator`, and `ProjectionServiceCollectionExtensionsTests`.

---

## 7. `IEventStoreMaintenance.AddTagsAsync` ‚Äî Additive Tag Migration

> ‚úÖ **DONE** ‚Äî shipped in this session as a new feature request added mid-milestone.

Opossum now exposes `IEventStoreMaintenance` for strictly additive maintenance
operations. The only operation is `AddTagsAsync`, which retroactively adds tags to all
stored events of a given event type without modifying or deleting any existing tags.

**Key design decisions:**
- **Additive-only guarantee:** any requested tag whose key already exists on the event
  is silently skipped; no overwrite, no delete path exists.
- **Atomicity per event:** the append lock is acquired per-event so each file write and
  index update is atomic without blocking the entire migration.
- **DI registration:** `FileSystemEventStore` is registered once; both `IEventStore` and
  `IEventStoreMaintenance` resolve to the same singleton instance.
- **Result type:** `TagMigrationResult(int TagsAdded, int EventsProcessed)` gives callers
  a migration summary.

**New files:**
- `src/Opossum/IEventStoreMaintenance.cs`
- `src/Opossum/Core/TagMigrationResult.cs`
- `src/Opossum/Storage/FileSystem/FileSystemEventStore.Maintenance.cs`
- `tests/Opossum.UnitTests/Storage/FileSystem/EventStoreMaintenanceTests.cs` (9 tests)

**Modified files:**
- `src/Opossum/Storage/FileSystem/IndexManager.cs` ‚Äî `AddTagsToIndexAsync`
- `src/Opossum/DependencyInjection/ServiceCollectionExtensions.cs` ‚Äî dual registration

---

## Delivery order ‚Äî prioritised

Items are grouped into three tiers. Items within the same tier are independent and can
be implemented in parallel; each tier should be fully merged before the next begins to
keep the main branch green.

### Tier 1 ‚Äî Do first (small, self-contained, unblocks everything else)

| # | Item | Why first | Status |
|---|------|-----------|--------|
| 3 | **`Apply(SequencedEvent)` instead of `IEvent`** | Smallest change ‚Äî one line in `ProjectionManager`, mechanical find-and-replace across all projections. Establishes the corrected projection contract that streaming reads and multi-context will build on. Zero risk to storage or read paths. | ‚úÖ Done |
| 4 | **`CancellationToken` on `AppendAsync`** | One-parameter addition, breaking but trivial to migrate. Bundling it now avoids a fourth consecutive breaking release. Best done before multi-context adds more `AppendAsync` call sites that would also need updating. | ‚úÖ Done |

### Tier 2 ‚Äî Do second (stabilises `IEventStore`, moderate scope)

| # | Item | Why here | Status |
|---|------|----------|--------|
| 2 | **Streaming reads via `IAsyncEnumerable<SequencedEvent>`** | ~~Changes the `IEventStore` return type once; all internal consumers updated in the same pass.~~ See [ADR-003](../decisions/003-iasyncenumerable-not-implemented.md). | ‚ùå Will Not Implement |
| 5 | **`Tag` and `QueryItem` as immutable `record` types** | Fundamental types touched everywhere. Doing this immediately after the interface stabilises ‚Äî and before multi-context multiplies usage sites ‚Äî minimises churn. | ‚úÖ Done |
| 7 | **`IEventStoreMaintenance.AddTagsAsync`** | Mid-milestone addition. Additive API ‚Äî no breaking impact. Shipped alongside item 5 since both touch the core type surface. | ‚úÖ Done |

### Tier 3 ‚Äî Do third (architectural, builds on stabilised API)

| # | Item | Why here | Status |
|---|------|----------|--------|
| 1 | **Multi-context support** | ~~Largest change. Requires the streaming `IEventStore` signature from Tier 2.~~ See [ADR-004](../decisions/004-single-context-by-design.md). | ‚ùå Will Not Implement |
| 6 | **Extract `TagIndex`/`EventTypeIndex` duplication** | Pure internal refactor. No longer blocked on multi-context ‚Äî can be done independently. No public API impact. | ‚úÖ Done |

### Recommended commit sequence

```
1. Apply(SequencedEvent)             ‚Üí IProjectionDefinition, IProjectionWithRelatedEvents,  ‚úÖ DONE
                                       ProjectionManager (1 line), all projection impls
4a. Immutable record types           ‚Üí Tag, QueryItem, Metadata, DomainEvent,              ‚úÖ DONE
                                       SequencedEvent ‚Äî all init-only; test suite migrated
4b. AddTagsAsync                     ‚Üí IEventStoreMaintenance, TagMigrationResult,         ‚úÖ DONE
                                       FileSystemEventStore.Maintenance, IndexManager,
                                       ServiceCollectionExtensions, 9 new tests
2. CancellationToken on AppendAsync  ‚Üí IEventStore, FileSystemEventStore, all callers     ‚úÖ DONE
3. IAsyncEnumerable ReadAsync        ‚Üí ‚ùå WILL NOT IMPLEMENT ‚Äî see ADR-003
5. Multi-context support             ‚Üí ‚ùå WILL NOT IMPLEMENT ‚Äî see ADR-004
6. Extract TagIndex/EventTypeIndex   ‚Üí PositionIndexFile shared utility              ‚úÖ DONE
8. AddContext ‚Üí UseStore rename      ‚Üí OpossumOptions, all callers, tests, docs             ‚úÖ DONE
```

## 8. `AddContext` ‚Üí `UseStore` Rename

> ‚úÖ **DONE** ‚Äî shipped in this session.

`OpossumOptions.AddContext(string)` was replaced with `UseStore(string)` and the
`Contexts` list property was replaced with a single `StoreName` string property.

### Motivation

- `AddContext` implied you could (and should) add multiple contexts. The verb `Add`
  combined with a `List<string>` property created a false affordance for multi-context
  usage that was never supported.
- `UseStore` reads as a fluent setter ‚Äî it configures _this_ instance's store name,
  not accumulates a collection.
- `StoreName` (singular string) is unambiguous about the one-store design. Accessing
  the store name no longer requires the `[0]` index pattern.

### Breaking changes

| Before (0.2.x) | After (0.3.0) |
|---|---|
| `options.AddContext("MyApp")` | `options.UseStore("MyApp")` |
| `options.Contexts` (`List<string>`) | `options.StoreName` (`string?`) |
| Silent no-op on second `AddContext` call | `InvalidOperationException` on second `UseStore` call |
| `IEventStoreMaintenance.AddTagsAsync(..., string? context, ...)` | `IEventStoreMaintenance.AddTagsAsync(...)` ‚Äî `context` parameter removed |

### Migration

```csharp
// Before
builder.Services.AddOpossum(options =>
{
    options.RootPath = @"D:\EventStore";
    options.AddContext("CourseManagement");
});

// After
builder.Services.AddOpossum(options =>
{
    options.RootPath = @"D:\EventStore";
    options.UseStore("CourseManagement");
});
```

---

## Deferred backlog

> **Promoted to milestone:** `CancellationToken` on `AppendAsync`, `Tag`/`QueryItem` records,
> and `TagIndex`/`EventTypeIndex` extraction are no longer deferred ‚Äî see Tiers 1‚Äì3 above.

| Priority | Item | Why deferred |
|----------|------|--------------|
| ‚úÖ Resolved | Metadata mutation side-effect in `AppendAsync` | Resolved as part of making `Metadata`, `DomainEvent`, and `SequencedEvent` immutable `record` types ‚Äî `AppendAsync` now creates a new `Metadata` instance with `Timestamp` defaulted to `UtcNow` instead of mutating the caller‚Äôs object. |

> **Moved to 0.4.0:** Cache compiled delegate in `ReflectionMessageHandler` ‚Äî performance
> work that does not touch any 0.3.0 API surface and carries non-trivial implementation risk.
> See [0.4.0 roadmap](./0.4.0-roadmap.md).

---

## Pre-Release Documentation Cleanup

Identified during final review before benchmark run. All items are doc-only ‚Äî no code changes.

### ‚ùå Must Fix ‚Äî factual errors visible to consumers

| # | File | Issue | Status |
|---|------|-------|--------|
| 1 | `CHANGELOG.md` | Two false entries describe `IAsyncEnumerable` streaming as shipped (it was explicitly Will Not Implement per ADR-003): **"Breaking: `IEventStore.ReadAsync` return type changed to `IAsyncEnumerable<SequencedEvent>`"** and **"`ProjectionManager.RebuildAsync` and `ProjectionDaemon` adopt `await foreach` streaming"** ‚Äî both must be removed | ‚úÖ Done |
| 0 | `Opossum.csproj` `<PackageReleaseNotes>` | Claimed "streaming reads via IAsyncEnumerable, and multi-context support" ‚Äî both Will Not Implement. Replaced with accurate breaking-changes summary + CHANGELOG link | ‚úÖ Done |

### ‚ö†Ô∏è Should Fix ‚Äî stale API in consumer-facing docs

| # | File | Issue | Status |
|---|------|-------|--------|
| 2 | `README.md` line 573 | `options.AddContext("MyApplicationContext")` ‚Üí `options.UseStore(...)` | ‚úÖ Done |
| 3 | `README.md` line 623 | `options.AddContext(context)` ‚Üí `options.UseStore(context)` (inside a loop ‚Äî see note) | ‚úÖ Done |

### üî∂ Low Priority ‚Äî internal/historical docs

| # | File | Occurrences | Status |
|---|------|-------------|--------|
| 4 | `docs/guides/durability-quick-reference.md` | 3 √ó `AddContext` (lines 17, 25, 97) | ‚úÖ Done |
| 5 | `docs/implementation/durability-guarantees.md` | 4 √ó `AddContext` (lines 106, 114, 533, 541) | ‚úÖ Done |
| 6 | `docs/implementation/dataseeder-fix-complete.md` | 1 √ó `AddContext` (line 54) | ‚úÖ Done |
| 7 | `docs/implementation/phase-1-2-summary.md` | 1 √ó `AddContext` (line 84) | ‚úÖ Done |
| 8 | `docs/specifications/spec-002-cache-warming.md` | 1 √ó `AddContext` (line 188) | ‚úÖ Done |

### ‚ö†Ô∏è Additional ‚Äî found during verification pass

| # | File | Issue | Status |
|---|------|-------|--------|
| 9 | `CONTRIBUTING.md` line 241 | `options.AddContext("TestContext")` in contributor test example | ‚úÖ Done |
| 10 | `docs/configuration-validation.md` line 251 | `AddContext` loop in validation example | ‚úÖ Done |

### üî∂ Historical-only docs ‚Äî intentional old-API references

These documents describe bugs or analyses that were written against the old `AddContext` API.
They are internal notes, not consumer guides; updating them is low value.

| # | File | Note |
|---|------|------|
| 11 | `docs/bind-order-fix.md` line 95 | Documents a historical bug in the old `Contexts` loop pattern ‚Äî intentionally shows old code |
| 12 | `docs/testing-configuration-override-fix.md` line 66 | Internal fix analysis against old API |
| 13 | `docs/ubuntu-test-failures-analysis.md` lines 50, 103 | Internal failure analysis against old API |
| 14 | `docs/decisions/002-nuget-release-readiness-assessment.md` lines 337, 477 | ADR written against 0.2.x API ‚Äî historical record |
